<script src="lib/fx.js"></script>

## 지연된 함수열을 병렬적으로 평가하기  - C.reduce, C.take

<script>
    const C ={};
    function noop(){}

    const catchNoop = arr =>
        (arr.forEach(a => a instanceof Promise ? a.catch(noop) : a), arr);

    C.reduce = curry((f, acc, iter) => {
        const iter2 = catchNoop(iter ? [...iter] : [...acc]);
        return iter ?
            reduce(f, acc, [...iter2]) :
            reduce(f, iter2);
    });

    C.take = curry((l, iter) => {
        iter = catchNoop([...iter]);
        return take(l, iter);
    });

    C.takeAll = C.take(Infinity);

    C.map = curry(pipe(L.map, C.takeAll));

    C.filter = curry(pipe(L.filter, C.takeAll));

    // const delay500 = a => new Promise(resolve => {
    //     console.log('hi~');
    //     setTimeout(() => resolve(a), 500);
    // });

    const delay1000 = a => new Promise(resolve => {
        setTimeout(() => resolve(a),1000)
    })

    // go([1,2,3,4,5],
    //     L.map(a => delay500(a * a)),
    //     L.filter(a => a %2),
    //     C.take(2),
    //     C.reduce(add),
    //     log
    // );
</script>

## 즉시 병렬적으로 평가하기 - C.map, C.filter

<script>
    C.map(a=> delay1000(a*a), [1,2,3,4]).then(log);
    C.filter(a=>delay1000(a % 2), [1,2,3,4]).then(log);
</script>

## 즉시 지연, Promise, 병렬적 조합하기

<script>
    const delay500 = (a, name) => new Promise(resolve => {
        log(`${name}: ${a}`);
        setTimeout(()=> resolve(a),500);
    });

    console.time('');
    go([1,2,3,4,5,6,7,8],
        L.map(a => delay500(a*a, 'map1')),
        L.filter( a=> delay500(a%2, 'filter2')),
        L.map(a=> delay500(a+1, 'map3')),
        take(2),
        log
    )
</script>